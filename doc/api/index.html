<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="description" content="rdf_mapper_annotations API docs, for the Dart programming language.">
  <title>rdf_mapper_annotations - Dart API docs</title>


  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet">
  
  <link rel="stylesheet" href="static-assets/github.css?v1">
  <link rel="stylesheet" href="static-assets/styles.css?v1">
  <link rel="icon" href="static-assets/favicon.png?v1">
  
</head>

<body data-base-href="" data-using-base-href="false" class="light-theme">
<div id="overlay-under-drawer"></div>
<header id="title">
  <span id="sidenav-left-toggle" class="material-symbols-outlined" role="button" tabindex="0">menu</span>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="https://kkalass.github.io/rdf_mapper_annotations/">rdf_mapper_annotations package</a></li>
  </ol>
  <div class="self-name">rdf_mapper_annotations</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
  <button class="toggle" id="theme-button" title="Toggle between light and dark mode" aria-label="Light and dark mode toggle">
    <span id="dark-theme-button" class="material-symbols-outlined" aria-hidden="true">
      dark_mode
    </span>
    <span id="light-theme-button" class="material-symbols-outlined" aria-hidden="true">
      light_mode
    </span>
  </button>
</header>
<main>
  <div id="dartdoc-main-content" class="main-content">
      
<section class="desc markdown">
  <h1 id="rdf-mapper-annotations-for-dart">RDF Mapper Annotations for Dart</h1>
<blockquote>
<p><strong>üéØ Code Generation Now Available</strong><br>
This library provides the annotation system for mapping Dart objects to RDF graphs. Use it with the <code>rdf_mapper_generator</code> package (v0.2.1+) to automatically generate type-safe mapping code from your annotated classes.</p>
</blockquote>
<p><a href="https://pub.dev/packages/rdf_mapper_annotations"><img src="https://img.shields.io/pub/v/rdf_mapper_annotations.svg" alt="pub package"></a>
<a href="https://github.com/kkalass/rdf_mapper_annotations/actions"><img src="https://github.com/kkalass/rdf_mapper_annotations/actions/workflows/ci.yml/badge.svg" alt="build"></a>
<a href="https://codecov.io/gh/kkalass/rdf_mapper_annotations"><img src="https://codecov.io/gh/kkalass/rdf_mapper_annotations/branch/main/graph/badge.svg" alt="codecov"></a>
<a href="https://github.com/kkalass/rdf_mapper_annotations/blob/main/LICENSE"><img src="https://img.shields.io/github/license/kkalass/rdf_mapper_annotations.svg" alt="license"></a></p>
<p>A powerful, declarative annotation system for seamless mapping between Dart objects and RDF graphs.</p>
<h2 id="overview">Overview</h2>
<p><a href="https://kkalass.github.io/rdf_mapper_annotations/">üåê <strong>Official Homepage</strong></a></p>
<p><code>rdf_mapper_annotations</code> provides the annotation system for declaring how to map between Dart objects and RDF data, similar to how an ORM works for databases. These annotations are processed by the <code>rdf_mapper_generator</code> package to generate the actual mapping code at build time.</p>
<p><strong>To use these annotations:</strong></p>
<ol>
<li>Annotate your Dart classes with the provided RDF annotations</li>
<li>Run the <code>rdf_mapper_generator</code> code generator to create mapping code</li>
<li>Use the generated mappers to serialize/deserialize between Dart objects and RDF formats</li>
</ol>
<p>With this declarative approach, you can define how your domain model maps to RDF without writing boilerplate serialization code.</p>
<h3 id="key-features">Key Features</h3>
<ul>
<li><strong>Declarative annotations</strong> for clean, maintainable code</li>
<li><strong>Type-safe mapping</strong> between Dart classes and RDF resources</li>
<li><strong>Support for code generation</strong> (via rdf_mapper_generator)</li>
<li><strong>Lossless RDF mapping</strong> with <code>@RdfUnmappedTriples</code> for perfect round-trip preservation</li>
<li><strong>Flexible IRI generation strategies</strong> for resource identification</li>
<li><strong>Comprehensive collection support</strong> for lists, sets, and maps</li>
<li><strong>Native enum support</strong> with custom values and IRI templates</li>
<li><strong>Extensible architecture</strong> through custom mappers</li>
</ul>
<h2 id="part-of-a-family-of-projects">Part of a Family of Projects</h2>
<p>This library is part of a comprehensive ecosystem for working with RDF in Dart:</p>
<ul>
<li><a href="https://github.com/kkalass/rdf_core">rdf_core</a> - Core graph classes and serialization (Turtle, JSON-LD, N-Triples)</li>
<li><a href="https://github.com/kkalass/rdf_mapper">rdf_mapper</a> - Base mapping system between Dart objects and RDF</li>
<li><a href="https://github.com/kkalass/rdf_mapper_generator">rdf_mapper_generator</a> - Code generator for this annotation library</li>
<li><a href="https://github.com/kkalass/rdf_vocabularies">rdf_vocabularies</a> - Constants for common RDF vocabularies (Schema.org, FOAF, etc.)</li>
<li><a href="https://github.com/kkalass/rdf_xml">rdf_xml</a> - RDF/XML format support</li>
<li><a href="https://github.com/kkalass/rdf_vocabulary_to_dart">rdf_vocabulary_to_dart</a> - Generate constants for custom vocabularies</li>
</ul>
<h2 id="what-is-rdf">What is RDF?</h2>
<p><a href="https://www.w3.org/RDF/">Resource Description Framework (RDF)</a> is a standard model for data interchange on the Web. RDF represents information as simple statements in the form of subject-predicate-object triples. This library lets you work with RDF data using familiar Dart objects without needing to manage triples directly.</p>
<h3 id="key-rdf-terms">Key RDF Terms</h3>
<p>To better understand this library, it's helpful to know these core RDF concepts:</p>
<ul>
<li>
<p><strong>IRI</strong> (International Resource Identifier): A unique web address that identifies a resource (similar to a URL but more flexible). In RDF, IRIs serve as global identifiers for things.</p>
</li>
<li>
<p><strong>Triple</strong>: The basic data unit in RDF, composed of subject-predicate-object. For example: "Book123 (subject) has-author (predicate) Person456 (object)".</p>
</li>
<li>
<p><strong>Literal</strong>: A simple data value like a string, number, or date that appears as an object in a triple.</p>
</li>
<li>
<p><strong>Blank Node</strong>: An anonymous resource that exists only in the context of other resources.</p>
</li>
<li>
<p><strong>Subject</strong>: The resource a triple is describing (always an IRI or blank node).</p>
</li>
<li>
<p><strong>Predicate</strong>: The property or relationship between the subject and object (always an IRI).</p>
</li>
<li>
<p><strong>Object</strong>: The value or resource that relates to the subject (can be an IRI, blank node, or literal).</p>
</li>
</ul>
<h2 id="quick-start">Quick Start</h2>
<p><strong>Prerequisites:</strong> This library requires the <code>rdf_mapper_generator</code> package to generate the actual mapping code from your annotations.</p>
<ol>
<li>Add dependencies to your project:</li>
</ol>
<pre class="language-bash"><code class="language-bash"># Add runtime dependencies
dart pub add rdf_core rdf_mapper rdf_mapper_annotations
dart pub add rdf_vocabularies  # Optional but recommended for standard vocabularies

# Add development dependencies (required for code generation)
dart pub add build_runner --dev
dart pub add rdf_mapper_generator --dev  # Version 0.2.1 or higher
</code></pre>
<ol start="2">
<li>Define your data model with RDF annotations:</li>
</ol>
<pre class="language-dart"><code class="language-dart">import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper_annotations/rdf_mapper_annotations.dart';
import 'package:rdf_vocabularies/schema.dart';

@RdfGlobalResource(
  SchemaBook.classIri, 
  IriStrategy('http://example.org/book/{id}')
)
class Book {
  @RdfIriPart()
  final String id;

  @RdfProperty(SchemaBook.name)
  final String title;

  @RdfProperty(
    SchemaBook.author,
    iri: IriMapping('http://example.org/author/{authorId}')
  )
  final String authorId;

  @RdfProperty(SchemaBook.hasPart)
  final Iterable&lt;Chapter&gt; chapters;

  Book({
    required this.id,
    required this.title,
    required this.authorId,
    required this.chapters,
  });
}

@RdfLocalResource(SchemaChapter.classIri)
class Chapter {
  @RdfProperty(SchemaChapter.name)
  final String title;

  @RdfProperty(SchemaChapter.position)
  final int number;

  Chapter(this.title, this.number);
}
</code></pre>
<ol start="3">
<li><strong>Generate the mapping code</strong> using the <code>rdf_mapper_generator</code>:</li>
</ol>
<pre class="language-bash"><code class="language-bash"># This command processes your annotations and generates the mapping code
dart run build_runner build --delete-conflicting-outputs
</code></pre>
<p>This will generate:</p>
<ul>
<li>A <code>rdf_mapper.g.dart</code> file with the initialization function</li>
<li>Individual mapper files for each annotated class</li>
<li>Type-safe serialization/deserialization code</li>
</ul>
<ol start="4">
<li>Use the generated mappers:</li>
</ol>
<pre class="language-dart"><code class="language-dart">import 'package:rdf_core/rdf_core.dart';
import 'package:rdf_mapper/rdf_mapper.dart';
import 'package:rdf_mapper_annotations/rdf_mapper_annotations.dart';
// Import the generated mapper initialization file
import 'package:your_package/rdf_mapper.g.dart';

void main() {
  // Initialize the generated mapper
  final mapper = initRdfMapper();
  
  // Create a book with chapters
  final book = Book(
    id: '123',
    title: 'RDF Mapping with Dart',
    authorId: 'k42',  // Will be mapped to http://example.org/author/k42
    chapters: [
      Chapter('Getting Started', 1),
      Chapter('Advanced Mapping', 2),
    ],
  );
  
  // Convert to serialized format (Turtle, JSON-LD, etc.)
  final turtle = mapper.encodeObject(book);
  print(turtle);
  
  // Parse back to Dart object
  final parsedBook = mapper.decodeObject&lt;Book&gt;(turtle);
  print(parsedBook.title); // 'RDF Mapping with Dart'
}
</code></pre>
<h2 id="how-it-works">How It Works</h2>
<p>This library follows a two-step process:</p>
<ol>
<li><strong>Annotation Phase</strong>: You annotate your Dart classes with RDF mapping annotations (this library)</li>
<li><strong>Code Generation Phase</strong>: The <code>rdf_mapper_generator</code> analyzes your annotations and generates efficient mapping code</li>
</ol>
<p><strong>Development Workflow:</strong></p>
<ul>
<li>Annotate your classes ‚Üí Run <code>dart run build_runner build</code> ‚Üí Use generated mappers</li>
<li>When you change annotations ‚Üí Re-run the build command ‚Üí Updated mappers are ready to use</li>
</ul>
<p>The generated code is type-safe, efficient, and handles all the RDF serialization/deserialization complexity for you.</p>
<h2 id="key-concepts">Key Concepts</h2>
<h3 id="class-annotations">Class Annotations</h3>
<ul>
<li><strong>@RdfGlobalResource</strong>: For primary entities with globally unique web addresses (IRIs). These become the "subjects" in RDF triples.</li>
<li><strong>@RdfLocalResource</strong>: For child entities that only exist in relation to their parent. These become "blank nodes" in RDF.</li>
<li><strong>@RdfIri</strong>: For classes representing web addresses (IRIs), used when you need a custom type for IRIs.</li>
<li><strong>@RdfLiteral</strong>: For classes representing simple values like strings, numbers, or custom formats with validation.</li>
</ul>
<h3 id="property-annotations">Property Annotations</h3>
<ul>
<li><strong>@RdfProperty</strong>: Maps a Dart class property to an RDF relation (predicate). Defines how properties connect to other resources.</li>
<li><strong>@RdfIriPart</strong>: Marks fields that help construct the resource's web address (IRI).</li>
<li><strong>@RdfValue</strong>: Identifies which field provides the actual data value for a literal.</li>
<li><strong>@RdfMapEntry</strong>: Specifies how key-value pairs are converted to RDF (since RDF has no native map concept).</li>
</ul>
<h3 id="iri-strategies">IRI Strategies</h3>
<p>RDF Mapper provides flexible strategies for generating and parsing IRIs for resources.</p>
<h4 id="simple-template-based-iris">Simple Template-based IRIs</h4>
<p>The most common approach uses a template with placeholders:</p>
<pre class="language-dart"><code class="language-dart">@RdfGlobalResource(
  Person.classIri, 
  IriStrategy('https://example.org/people/{id}')
)
class Person {
  @RdfIriPart()  // Will be substituted into {id} in the template
  final String id;
  
  // Other properties...
}
</code></pre>
<h4 id="direct-iri-storage">Direct IRI Storage</h4>
<p>For cases when you want to store the full IRI in the object:</p>
<pre class="language-dart"><code class="language-dart">@RdfGlobalResource(
  SchemaPerson.classIri, 
  IriStrategy()  // Empty strategy means use the IRI field directly
)
class Person {
  @RdfIriPart()  // Contains the complete IRI
  final String iri;
  
  // Other properties...
}
</code></pre>
<h4 id="multi-part-iris">Multi-part IRIs</h4>
<p>For IRIs constructed from multiple fields:</p>
<pre class="language-dart"><code class="language-dart">@RdfGlobalResource(
  SchemaChapter.classIri,
  IriStrategy('https://example.org/books/{bookId}/chapters/{chapterNumber}')
)
class Chapter {
  @RdfIriPart()  // Maps to {bookId}
  final String bookId;
  
  @RdfIriPart("chapterNumber")  // Maps to {chapterNumber}
  final int number;
  
  // Other properties...
}
</code></pre>
<h4 id="globally-injected-placeholders">Globally Injected Placeholders</h4>
<p>Use globally injected placeholders for values that should be provided at runtime:</p>
<pre class="language-dart"><code class="language-dart">// Define models with configurable base URIs
@RdfGlobalResource(
  SchemaPerson.classIri, 
  IriStrategy('{+baseUri}/persons/{id}')  // {baseUri} is not directly from a class field and is marked with +, thus matches including /
)
class Person {
  @RdfIriPart()
  final String id;
  
  @RdfProperty(SchemaPerson.name)
  final String name;
  
  Person({required this.id, required this.name});
}

@RdfGlobalResource(
  SchemaOrganization.classIri, 
  IriStrategy('{+baseUri}/organizations/{id}')  // Same placeholder across models
)
class Organization {
  @RdfIriPart()
  final String id;
  
  @RdfProperty(SchemaOrganization.name)
  final String name;
  
  Organization({required this.id, required this.name});
}

// At runtime, provide values for the global placeholders
void main() {
  // The generated initRdfMapper function will require providers for global placeholders
  final mapper = initRdfMapper(
    // Provide a function that returns the baseUri value
    baseUriProvider: () =&gt; 'https://user-specific-domain.com',
  );
  
  // Now when you create and serialize objects, the baseUri will be injected
  final person = Person(id: '123', name: 'Alice');
  final org = Organization(id: 'acme', name: 'ACME Inc.');
  
  // IRI will be: https://user-specific-domain.com/persons/123
  final personGraph = mapper.encodeObject(person);
  
  // IRI will be: https://user-specific-domain.com/organizations/acme
  final orgGraph = mapper.encodeObject(org);
}
</code></pre>
<p>This approach is particularly useful for:</p>
<ul>
<li>Multi-tenant applications where each tenant has their own domain</li>
<li>Applications that need to switch between development/staging/production URLs</li>
<li>Supporting user-specific or deployment-specific base URIs</li>
<li>Maintaining a consistent IRI structure across your entire model</li>
</ul>
<h4 id="custom-mapper-for-complex-cases">Custom Mapper for Complex Cases</h4>
<p>When you need complete control over IRI generation and parsing:</p>
<pre class="language-dart"><code class="language-dart">@RdfGlobalResource(
  SchemaChapter.classIri,
  IriStrategy.namedMapper('chapterIdMapper')  // Reference to your custom mapper
)
class Chapter {
  @RdfIriPart.position(1)  // Position in the record type used by the mapper
  final String bookId;
  
  @RdfIriPart.position(2)  // Position matters for the record type
  final int chapterNumber;
  
  // Other properties...
}

// Your custom IRI mapper implementation
class ChapterIdMapper implements IriTermMapper&lt;(String bookId, int chapterId)&gt; {
  final String baseUrl;
  
  ChapterIdMapper({required this.baseUrl});
  
  @override
  IriTerm toRdfTerm((String, int) value, SerializationContext context) {
    return IriTerm('$baseUrl/books/${value.$1}/chapters/${value.$2}');
  }
  
  @override
  (String, int) fromRdfTerm(IriTerm term, DeserializationContext context) {
    // Parse the IRI and extract components
    final uri = Uri.parse(term.iri);
    final segments = uri.pathSegments;
    
    // Expected path: /books/{bookId}/chapters/{chapterId}
    if (segments.length &gt;= 4 &amp;&amp; segments[0] == 'books' &amp;&amp; segments[2] == 'chapters') {
      return (segments[1], int.parse(segments[3]));
    }
    
    throw FormatException('Invalid Chapter IRI format: ${term.iri}');
  }
}
</code></pre>
<h3 id="iri-property-mapping">IRI Property Mapping</h3>
<p>When a property should reference another resource (rather than contain a literal value), use <code>IriMapping</code> to generate proper IRIs from simple values:</p>
<pre class="language-dart"><code class="language-dart">class Book {
  // Maps the string "k42" to the IRI "http://example.org/author/k42"
  @RdfProperty(
    SchemaBook.author,  // Expects an IRI to a Person
    iri: IriMapping('http://example.org/author/{authorId}')
  )
  final String authorId;
  
  // ...
}
</code></pre>
<p>This is especially valuable for:</p>
<ul>
<li>Referencing external resources with IRIs</li>
<li>Creating semantic connections between objects</li>
<li>Adhering to vocabulary specifications (like Schema.org)</li>
<li>Maintaining proper RDF graph structure when a predicate expects an IRI rather than a literal</li>
</ul>
<hr>
<h2 id="advanced-features">Advanced Features</h2>
<h3 id="custom-types-and-literals">Custom Types and Literals</h3>
<p>Create custom types with specialized serialization:</p>
<pre class="language-dart"><code class="language-dart">@RdfLiteral()
class Rating {
  @RdfValue()
  final int stars;
  
  Rating(this.stars) {
    if (stars &lt; 0 || stars &gt; 5) {
      throw ArgumentError('Rating must be between 0 and 5 stars');
    }
  }
}

@RdfLiteral.custom(
  toLiteralTermMethod: 'formatCelsius',
  fromLiteralTermMethod: 'parse',
  datatype: IriTerm.prevalidated('http://example.org/temperature')
)
class Temperature {
  final double celsius;
  
  Temperature(this.celsius);
  
  LiteralContent formatCelsius() =&gt; LiteralContent('$celsius¬∞C');
  
  static Temperature parse(LiteralContent term) {
    return Temperature(double.parse(term.value.replaceAll('¬∞C', '')));
  }
}
</code></pre>
<h3 id="internationalization-support">Internationalization Support</h3>
<p>Handle localized texts with language tags:</p>
<pre class="language-dart"><code class="language-dart">@RdfLiteral()
class LocalizedText {
  @RdfValue()
  final String text;
  
  @RdfLanguageTag()
  final String languageTag;
  
  LocalizedText(this.text, this.languageTag);
  
  // Convenience constructors
  LocalizedText.en(String text) : this(text, 'en');
  LocalizedText.de(String text) : this(text, 'de');
}
</code></pre>
<h3 id="collection-handling">Collection Handling</h3>
<p>RDF Mapper provides flexible support for collection types (List, Set, Iterable) and Map collections with different serialization strategies.</p>
<h4 id="standard-collections-list-set-iterable">Standard Collections (List, Set, Iterable)</h4>
<p>By default, standard Dart collections are serialized as multiple separate RDF triples with the same predicate:</p>
<pre class="language-dart"><code class="language-dart">class Book {
  // Uses UnorderedItemsListMapper automatically - each author generates a separate triple
  @RdfProperty(SchemaBook.author)
  final List&lt;Person&gt; authors;
  
  // Uses UnorderedItemsSetMapper automatically - each keyword as separate triple
  @RdfProperty(SchemaBook.keywords)
  final Set&lt;String&gt; keywords;
  
  // Uses UnorderedItemsMapper automatically - recommended for semantic clarity
  @RdfProperty(SchemaBook.contributors)
  final Iterable&lt;Person&gt; contributors;
}
</code></pre>
<p><strong>Important notes about default collection behavior:</strong></p>
<ul>
<li><strong>Order is not preserved</strong> in RDF representation</li>
<li>Each item generates its own triple: <code>book:123 schema:author person:1</code>, <code>book:123 schema:author person:2</code></li>
<li><strong>NOT</strong> serialized as RDF Collection structures (rdf:first/rdf:rest/rdf:nil)</li>
<li>Use <code>Iterable&lt;T&gt;</code> for clarity that order shouldn't be relied upon</li>
<li><strong>Default behavior</strong>: Unlike other mapping properties (<code>iri</code>, <code>literal</code>, <code>globalResource</code>, <code>localResource</code>) which default to registry lookup when not specified, collections have a different default. When no <code>collection</code> parameter is specified on <code>Set</code>, <code>List</code>, <code>Map</code>, or <code>Iterable</code> properties, it defaults to <code>collection: CollectionMapping.auto()</code> (which provides the automatic behavior described above)</li>
<li><strong>Registry lookup</strong>: To use registry-based mapper lookup (matching the default behavior of other mapping properties), explicitly specify <code>collection: CollectionMapping.fromRegistry()</code></li>
</ul>
<h4 id="custom-collection-mappers">Custom Collection Mappers</h4>
<p>Use the <code>collection</code> parameter to specify custom collection mapping strategies:</p>
<pre class="language-dart"><code class="language-dart">class Book {
  // Structured RDF List (preserves order)
  @RdfProperty(SchemaBook.chapters, collection: rdfList)
  final List&lt;Chapter&gt; chapters;
  
  // RDF Sequence structure
  @RdfProperty(SchemaBook.authors, collection: rdfSeq)
  final List&lt;Person&gt; authors;
  
  // Custom collection behavior - treating entire collection as single value
  @RdfProperty(SchemaBook.keywords, collection: CollectionMapping.mapper(StringListMapper))
  final List&lt;String&gt; keywords; // Uses custom collection mapper for entire list
}
</code></pre>
<h4 id="item-mapping-within-collections">Item Mapping within Collections</h4>
<p>The <code>iri</code>, <code>literal</code>, <code>globalResource</code>, and <code>localResource</code> parameters configure how individual items are mapped:</p>
<pre class="language-dart"><code class="language-dart">class Book {
  // Default collection behavior (multiple triples) with custom item mapping
  @RdfProperty(
    SchemaBook.authors,
    iri: IriMapping('{+baseUri}/person/{authorId}')
  )
  final List&lt;String&gt; authorIds; // Each ID converted to IRI, separate triples
  
  // Default collection with custom literal mapping for each item
  @RdfProperty(
    SchemaBook.tags,
    literal: LiteralMapping.withLanguage('en')
  )
  final List&lt;String&gt; tags; // Each tag as separate literal with @en language tag
  
  // Structured collection with custom item mapping
  @RdfProperty(
    SchemaBook.chapters,
    collection: rdfList,
    globalResource: GlobalResourceMapping.namedMapper('chapterMapper')
  )
  final List&lt;Chapter&gt; chapters;
}
</code></pre>
<h3 id="map-collections">Map Collections</h3>
<p>RDF has no native concept of key-value pairs. This library provides two different approaches for mapping Map&lt;K,V&gt; collections:</p>
<h4 id="1-using-a-dedicated-entry-class-most-common-approach">1. Using a dedicated entry class (Most common approach)</h4>
<p>This approach uses a class with <code>@RdfMapKey</code> and <code>@RdfMapValue</code> annotations:</p>
<pre class="language-dart"><code class="language-dart">// In your main class
class Task {
  @RdfProperty(TaskVocab.vectorClock)
  @RdfMapEntry(VectorClockEntry)  // Specify the entry class
  Map&lt;String, int&gt; vectorClock;  // clientId ‚Üí version number
}

// The entry class with key and value properties
@RdfLocalResource(VectorClockVocab.classIri)  
class VectorClockEntry {
  @RdfProperty(VectorClockVocab.clientId)
  @RdfMapKey()  // This property provides the Map key
  final String clientId;

  @RdfProperty(VectorClockVocab.clockValue)
  @RdfMapValue()  // This property provides the Map value 
  final int clockValue;

  VectorClockEntry(this.clientId, this.clockValue);
}
</code></pre>
<p>Each map entry is represented as a separate resource in the RDF graph with its own properties.</p>
<h4 id="2-using-a-custom-mapper-for-special-cases">2. Using a custom mapper (For special cases)</h4>
<p>This approach handles map entries directly without separate resources:</p>
<pre class="language-dart"><code class="language-dart">// Direct mapping using a custom mapper
class Book {
  @RdfProperty(
    BookVocab.title,
    literal: LiteralMapping.mapperInstance(const LocalizedEntryMapper())
  )
  final Map&lt;String, String&gt; translations;  // language ‚Üí translated text
  
  Book({required this.translations});
}

// Custom mapper converts between Map entries and RDF literals
class LocalizedEntryMapper implements LiteralTermMapper&lt;MapEntry&lt;String, String&gt;&gt; {
  const LocalizedEntryMapper();

  @override
  MapEntry&lt;String, String&gt; fromRdfTerm(LiteralTerm term, DeserializationContext context) =&gt;
    MapEntry(term.language ?? 'en', term.value);

  @override
  LiteralTerm toRdfTerm(MapEntry&lt;String, String&gt; value, SerializationContext context) =&gt;
    LiteralTerm.withLanguage(value.value, value.key);
}
</code></pre>
<p>In this example, map entries are serialized as language-tagged literals, where the key becomes the language tag and the value becomes the literal value.</p>
<h3 id="lossless-rdf-mapping">Lossless RDF Mapping</h3>
<p>Preserve all RDF data during serialization/deserialization cycles with lossless mapping features:</p>
<h4 id="rdfunmappedtriples---catch-all-for-unknown-properties">@RdfUnmappedTriples - Catch-All for Unknown Properties</h4>
<p>Use <code>@RdfUnmappedTriples()</code> to capture any RDF properties that aren't explicitly mapped to other fields:</p>
<pre class="language-dart"><code class="language-dart">@RdfGlobalResource(SchemaPerson.classIri, IriStrategy("https://example.org/people/{id}"))
class Person {
  @RdfIriPart("id")
  final String id;

  @RdfProperty(SchemaPerson.name)
  final String name;

  // Captures email, telephone, and any other unmapped properties
  @RdfUnmappedTriples()
  final RdfGraph unmappedProperties;

  Person({required this.id, required this.name, RdfGraph? unmappedProperties})
    : unmappedProperties = unmappedProperties ?? RdfGraph(triples: []);
}
</code></pre>
<h4 id="rdfgraph-as-property-type">RdfGraph as Property Type</h4>
<p>Use <code>RdfGraph</code> as a regular property type to capture structured subgraphs without creating custom classes:</p>
<pre class="language-dart"><code class="language-dart">class Person {
  @RdfProperty(SchemaPerson.name)
  final String name;

  // Captures address as a subgraph (streetAddress, city, postalCode, etc.)
  @RdfProperty(SchemaPerson.address)
  final RdfGraph? address;

  // Still preserves any other unmapped properties
  @RdfUnmappedTriples()
  final RdfGraph unmappedProperties;
}
</code></pre>
<h4 id="document-level-lossless-workflow">Document-Level Lossless Workflow</h4>
<p>For complete document preservation including unrelated entities, use the lossless methods:</p>
<pre class="language-dart"><code class="language-dart">// Decode with remainder - captures both object data and document-level unmapped data
final (person, remainderGraph) = mapper.decodeObjectLossless&lt;Person&gt;(turtle);

// person.unmappedProperties contains triples about the person that weren't mapped
// remainderGraph contains all other triples from the document (other entities, etc.)

// Encode back preserving everything - perfect round-trip
final restoredTurtle = mapper.encodeObjectLossless((person, remainderGraph));
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Perfect round-trip preservation</strong>: No data loss during Dart ‚Üî RDF conversion</li>
<li><strong>Future-proof</strong>: Handle evolving RDF schemas gracefully</li>
<li><strong>Flexibility</strong>: Mix strongly-typed properties with flexible graph storage</li>
<li><strong>Document integrity</strong>: Preserve entire RDF documents, not just individual objects</li>
</ul>
<p>See <code>example/catch_all.dart</code> for a complete demonstration.</p>
<h3 id="enum-support">Enum Support</h3>
<p>RDF Mapper provides comprehensive support for mapping Dart enums to RDF literals and IRIs with type safety and custom serialization values.</p>
<h4 id="basic-enum-mapping">Basic Enum Mapping</h4>
<p>Use <code>@RdfLiteral</code> for enums that should serialize as literal values:</p>
<pre class="language-dart"><code class="language-dart">@RdfLiteral()
enum BookFormat {
  hardcover,  // ‚Üí "hardcover"
  paperback,  // ‚Üí "paperback"
  ebook,      // ‚Üí "ebook"
}
</code></pre>
<p>Use <code>@RdfIri</code> with templates for enums that should serialize as IRIs:</p>
<pre class="language-dart"><code class="language-dart">@RdfIri('http://schema.org/{value}')
enum ItemCondition {
  brandNew,     // ‚Üí &lt;http://schema.org/brandNew&gt;
  used,         // ‚Üí &lt;http://schema.org/used&gt;
  refurbished,  // ‚Üí &lt;http://schema.org/refurbished&gt;
}
</code></pre>
<h4 id="custom-enum-values">Custom Enum Values</h4>
<p>Override individual enum constant serialization with <code>@RdfEnumValue</code>:</p>
<pre class="language-dart"><code class="language-dart">@RdfLiteral()
enum Priority {
  @RdfEnumValue('H')
  high,         // ‚Üí "H"
  
  @RdfEnumValue('M')
  medium,       // ‚Üí "M"
  
  @RdfEnumValue('L')
  low,          // ‚Üí "L"
}

@RdfIri('http://schema.org/{value}')
enum ItemCondition {
  @RdfEnumValue('NewCondition')
  brandNew,     // ‚Üí &lt;http://schema.org/NewCondition&gt;
  
  @RdfEnumValue('UsedCondition')
  used,         // ‚Üí &lt;http://schema.org/UsedCondition&gt;
  
  refurbished,  // ‚Üí &lt;http://schema.org/refurbished&gt; (uses enum name)
}
</code></pre>
<h4 id="enum-integration-with-resources">Enum Integration with Resources</h4>
<p>Enums work seamlessly with resource classes:</p>
<pre class="language-dart"><code class="language-dart">@RdfGlobalResource(BookVocab.classIri, IriStrategy('http://example.org/books/{id}'))
class Book {
  @RdfIriPart()
  final String id;

  @RdfProperty(BookVocab.format)
  final BookFormat format;  // Uses enum's @RdfLiteral mapping

  @RdfProperty(BookVocab.condition)
  final ItemCondition condition;  // Uses enum's @RdfIri mapping

  // Override with custom language tag for this property
  @RdfProperty(BookVocab.priority, literal: LiteralMapping.withLanguage('en'))
  final Priority priority;

  Book({required this.id, required this.format, required this.condition, required this.priority});
}
</code></pre>
<p>For detailed examples including advanced IRI templates with context variables, see the <a href="doc/enum_mapping_guide.md">Enum Mapping Guide</a>.</p>
<h3 id="using-custom-mappers">Using Custom Mappers</h3>
<p>For special cases, you can implement custom mappers alongside generated ones:</p>
<pre class="language-dart"><code class="language-dart">// Custom mapper implementation
class EventMapper implements GlobalResourceMapper&lt;Event&gt; {
  @override
  final IriTerm typeIri = EventVocab.classIri;
  
  @override
  RdfSubject toRdfResource(Event instance, SerializationContext context, {RdfSubject? parentSubject}) {
    // Custom serialization logic here
    return context.resourceBuilder(IriTerm('http://example.org/events/${instance.id}'))
      .addValue(EventVocab.timestamp, instance.timestamp)
      .addValues(instance.customData.entries.map(
        (e) =&gt; MapEntry(IriTerm('http://example.org/property/${e.key}'), e.value)))
      .build();
  }
  
  @override
  Event fromRdfResource(RdfSubject subject, DeserializationContext context) {
    // Custom deserialization logic here
    return Event(/* ... */);
  }
}

// Register your custom mapper with the system
final rdfMapper = initRdfMapper();
rdfMapper.registerMapper&lt;Event&gt;(EventMapper());

// Now use it alongside generated mappers
final eventGraph = rdfMapper.encodeObject(event);
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<p>To get the most out of RDF Mapper:</p>
<ul>
<li>
<p><strong>Use standard vocabularies</strong> - The <code>rdf_vocabularies</code> package provides ready-to-use constants for common vocabularies. Use the <a href="https://kkalass.github.io/rdf_vocabularies/api/index.html">online search tool</a> to discover terms.</p>
</li>
<li>
<p><strong>Choose the right resource type</strong>:</p>
<ul>
<li><code>@RdfGlobalResource</code> for entities with independent identity</li>
<li><code>@RdfLocalResource</code> for entities that only exist in context of a parent</li>
<li><code>@RdfLiteral</code> for values you want to serialize as a primitive like String, int etc.</li>
<li><code>@RdfIri</code> for IRI (similar to URL) reference values</li>
</ul>
</li>
<li>
<p><strong>Model relationships correctly</strong> - Use IRI mapping for references to other resources rather than string literals</p>
</li>
</ul>
<h2 id="learn-more">Learn More</h2>
<p>For detailed examples and advanced topics:</p>
<ul>
<li><strong><a href="doc/enum_mapping_guide.md">Enum Mapping Guide</a></strong> - Comprehensive guide to enum support with examples</li>
<li><strong><a href="https://github.com/kkalass/rdf_mapper_annotations/tree/main/example">Examples Directory</a></strong> - Complex mappings, vector clocks, IRI strategies, and more</li>
</ul>
<h2 id="-roadmap--next-steps">üõ£Ô∏è Roadmap / Next Steps</h2>
<ul>
<li>Schema generating based on annotations, for example <code>@RdfProperty.schemaDefine('https://my.app.com/vocab/MyType/myProp')</code> or similar</li>
</ul>
<h2 id="-contributing">ü§ù Contributing</h2>
<p>Contributions, bug reports, and feature requests are welcome!</p>
<ul>
<li>Fork the repo and submit a PR</li>
<li>See <a href="CONTRIBUTING.md">CONTRIBUTING.md</a> for guidelines</li>
<li>Join the discussion in <a href="https://github.com/kkalass/rdf_mapper_annotations/issues">GitHub Issues</a></li>
</ul>
<h2 id="-ai-policy">ü§ñ AI Policy</h2>
<p>This project is proudly human-led and human-controlled, with all key decisions, design, and code reviews made by people. At the same time, it stands on the shoulders of LLM giants: generative AI tools are used throughout the development process to accelerate iteration, inspire new ideas, and improve documentation quality. We believe that combining human expertise with the best of AI leads to higher-quality, more innovative open source software.</p>
<hr>
<p>¬© 2025 Klas Kala√ü. Licensed under the MIT License.</p>
</section>


      <section class="summary">
          <h2>Libraries</h2>
        <dl>
          <dt id="collection_constants">
  <span class="name"><a href="collection_constants/">collection_constants</a></span> 

</dt>
<dd>
</dd>

          <dt id="rdf_mapper_annotations">
  <span class="name"><a href="rdf_mapper_annotations/">rdf_mapper_annotations</a></span> 

</dt>
<dd>Annotation library for mapping Dart classes to RDF graphs.
</dd>

        </dl>
      </section>
  </div> <!-- /.main-content -->
  <div id="dartdoc-sidebar-left" class="sidebar sidebar-offcanvas-left">
    <!-- The search input and breadcrumbs below are only responsively visible at low resolutions. -->
<header id="header-search-sidebar" class="hidden-l">
  <form class="search-sidebar" role="search">
    <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>
<ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
    <li><a href="https://kkalass.github.io/rdf_mapper_annotations/">rdf_mapper_annotations package</a></li>
</ol>

    <h5 class="hidden-xs"><span class="package-name">rdf_mapper_annotations</span> <span class="package-kind">package</span></h5>
    <ol>
      <li class="section-title">Libraries</li>
      <li><a href="collection_constants/">collection_constants</a></li>
      <li><a href="rdf_mapper_annotations/">rdf_mapper_annotations</a></li>
</ol>

  </div>
  <div id="dartdoc-sidebar-right" class="sidebar sidebar-offcanvas-right">
  </div>
</main>
<footer>
  <span class="no-break">
    rdf_mapper_annotations
      0.3.0
  </span>
  
</footer>


<script src="static-assets/highlight.pack.js?v1"></script>
<script src="static-assets/docs.dart.js"></script>

</body>
</html>

